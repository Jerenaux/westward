/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./tools/worldMaker.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./shared/SpaceMap.js":
/*!****************************!*\
  !*** ./shared/SpaceMap.js ***!
  \****************************/
/*! exports provided: SpaceMap, SpaceMapList */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SpaceMap\", function() { return SpaceMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SpaceMapList\", function() { return SpaceMapList; });\n/**\r\n * Created by Jerome on 23-04-17.\r\n */\r\n\r\n\r\n// A space map is a custom data struture, similar to a sparse 2D array. Entities are stored according to their coordinates;\r\n// that is, two keys are needed to fetch entities, the x position and the y position. This allows fast look-up based on position,\r\n// e.g. var objectAtSomePosition = mySpaceMap.get(x,y);\r\nfunction SpaceMap(){}\r\n\r\nSpaceMap.prototype.add = function(x,y,object){\r\n    if(!this.hasOwnProperty(x))this[x] = {};\r\n    if(object === undefined) object = 1;\r\n    this[x][y] = object; // replaces any existing object\r\n};\r\n\r\nSpaceMap.prototype.accumulate = function(x,y,object,cb){\r\n    if(!this.hasOwnProperty(x))this[x] = {};\r\n    if(object === undefined) object = 1;\r\n    if(this[x][y]){\r\n        cb.call(this[x][y]);\r\n    }else{\r\n        this[x][y] = object;\r\n    }\r\n};\r\n\r\nSpaceMap.prototype.increment = function(x,y){\r\n    if(!this.hasOwnProperty(x))this[x] = {};\r\n    if(!this[x].hasOwnProperty(y)) this[x][y] = 0;\r\n    this[x][y]++;\r\n    return this[x][y];\r\n};\r\n\r\n// Works also by calling mySpaceMap[x][y]\r\nSpaceMap.prototype.get = function(x,y){\r\n    if(!this.hasOwnProperty(x)) return null;\r\n    if(!this[x].hasOwnProperty(y)) return null;\r\n    return this[x][y];\r\n};\r\n\r\nSpaceMap.prototype.has = function(x,y){\r\n    if(!this.hasOwnProperty(x)) return false;\r\n    return(this[x].hasOwnProperty(y));\r\n};\r\n\r\nSpaceMap.prototype.delete = function(x,y){\r\n    if(!this.hasOwnProperty(x)) return;\r\n    if(!this[x].hasOwnProperty(y)) return;\r\n    delete this[x][y];\r\n    if(Object.keys(this[x]).length == 0) delete this[x];\r\n};\r\n\r\nSpaceMap.prototype.getFirst = function(){\r\n    return this.toList()[0].v;\r\n};\r\n\r\nSpaceMap.prototype.merge = function(otherMap){\r\n    otherMap.toList().forEach(function(cell){\r\n        this.add(cell.x,cell.y);\r\n    },this);\r\n};\r\n\r\nSpaceMap.prototype.toList = function(compact,skipv){ // serialize to a list representation\r\n    var list = [];\r\n    for(var x in this){\r\n        if(this.hasOwnProperty(x)){\r\n            for(var y in this[x]){\r\n                if(this[x].hasOwnProperty(y)){\r\n                    if(compact){\r\n                        if(skipv){\r\n                            list.push([parseInt(x), parseInt(y)]);\r\n                        }else {\r\n                            list.push([parseInt(x), parseInt(y), this[x][y]]);\r\n                        }\r\n                    }else {\r\n                        if(skipv){\r\n                            list.push({\r\n                                x: x,\r\n                                y: y\r\n                            });\r\n                        }else {\r\n                            list.push({\r\n                                x: x,\r\n                                y: y,\r\n                                v: this[x][y]\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return list;\r\n};\r\n\r\nSpaceMap.prototype.fromList = function(list,compact) { // unserialize from list representation\r\n    for(var i = 0; i < list.length; i++){\r\n        var item = list[i];\r\n        if(compact){\r\n            this.add(item[0],item[1],(item[2] || {}))\r\n        }else {\r\n            this.add(item.x, item.y, (item.v || {}));\r\n        }\r\n    }\r\n};\r\n\r\nSpaceMap.prototype.toString = function(){ // serialize to a list representation\r\n    var s = \"\";\r\n    for(x in this){\r\n        if(this.hasOwnProperty(x)){\r\n            for(y in this[x]){\r\n                if(this[x].hasOwnProperty(y)) {\r\n                    s += \"(\"+x+\",\"+y+\",\"+this[x][y]+\")\";\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return s;\r\n};\r\n\r\n\r\n// ###############\r\n\r\nfunction SpaceMapList(){}\r\n\r\nSpaceMapList.prototype.add = function(x,y,object){\r\n    if(!this.hasOwnProperty(x))this[x] = {};\r\n    if(!this[x].hasOwnProperty(y)) this[x][y] = [];\r\n    if(object === undefined) object = 1;\r\n    this[x][y].push(object);\r\n};\r\n\r\n// Works also by calling mySpaceMap[x][y]\r\nSpaceMapList.prototype.get = function(x,y){\r\n    if(!this.hasOwnProperty(x)) return [];\r\n    if(!this[x].hasOwnProperty(y)) return [];\r\n    return this[x][y];\r\n};\r\n\r\nSpaceMapList.prototype.delete = function(x,y,object){\r\n    if(!this.hasOwnProperty(x)) return;\r\n    if(!this[x].hasOwnProperty(y)) return;\r\n    this[x][y].splice(this[x][y].findIndex(function(e){\r\n        return e.getShortID() == object.getShortID();\r\n    }),1);\r\n    if(Object.keys(this[x]).length == 0) delete this[x];\r\n};\r\n\r\n\n\n//# sourceURL=webpack:///./shared/SpaceMap.js?");

/***/ }),

/***/ "./shared/Utils.js":
/*!*************************!*\
  !*** ./shared/Utils.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _shared_World__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/World */ \"./shared/World.js\");\n/**\r\n * Created by Jerome on 11-08-17.\r\n */\r\n\r\nvar onServer = (typeof window === 'undefined');\r\n\r\n// if(onServer){\r\n//     World = require('./World.js').World;\r\n// }\r\n\r\n\r\nvar Utils = {\r\n    colors: {},\r\n    strokes: {},\r\n    fonts: {}\r\n};\r\n\r\nUtils.colors.white = '#ffffff';\r\nUtils.colors.gold = '#ffd700';\r\nUtils.colors.red = '#ff0000';\r\nUtils.colors.lightred = '#ff3b3b';\r\nUtils.colors.blue = '#558fff';\r\nUtils.strokes.red = '#331111';\r\nUtils.colors.green = '#11ee11';\r\n\r\nUtils.fonts.normal = 'arial';\r\nUtils.fonts.fancy = 'belwe';\r\n\r\n// ### Coordinates methodes ###\r\n\r\n/**\r\n * Return the AOI to which a tile belongs.\r\n * @param {Object|number} tile - {x,y} coordinates of tile, or alternatively the x coordinate only.\r\n * @param {number} y - The y coordinate of the tile.\r\n */\r\nUtils.tileToAOI = function(tile,y){\r\n    var tileX,tileY;\r\n    if(y !== undefined){\r\n        tileX = tile;\r\n        tileY = y;\r\n    }else{\r\n        tileX = tile.x;\r\n        tileY = tile.y;\r\n    }\r\n    if(!_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal) throw Error('Chunk data not initialized');\r\n    tileX = Utils.clamp(tileX,0,_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].worldWidth-1);\r\n    tileY = Utils.clamp(tileY,0,_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].worldHeight-1);\r\n    var top = Math.floor(tileY/_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].chunkHeight);\r\n    var left = Math.floor(tileX/_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].chunkWidth);\r\n    return (top*_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal)+left;\r\n};\r\n\r\nUtils.AOItoTile = function(aoi){\r\n    if(!_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal) throw Error('Chunk data not initialized');\r\n    return {\r\n        x : (aoi%_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal)*_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].chunkWidth,\r\n        y : Math.floor(aoi/_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal)*_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].chunkHeight\r\n    };\r\n};\r\n\r\nUtils.getAOIcorners = function(aoi){\r\n    // Returns in order: tl, tr, br, bl\r\n    var l = [];\r\n    var o = Utils.AOItoTile(aoi);\r\n    l.push(o);\r\n    l.push({x:o.x+_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].chunkWidth,y:o.y});\r\n    l.push({x:o.x+_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].chunkWidth,y:o.y+_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].chunkHeight});\r\n    l.push({x:o.x,y:o.y+_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].chunkHeight});\r\n    return l;\r\n};\r\n\r\nUtils.gridToLine = function(x,y,w){\r\n    return (y*w)+x;\r\n};\r\n\r\nUtils.gridToLineWithOrigin = function(x,y,w){\r\n    var aoi = Utils.tileToAOI({x:x,y:y});\r\n    var origin = Utils.AOItoTile(aoi);\r\n    return Utils.gridToLine(x-origin.x,y-origin.y,w);\r\n};\r\n\r\nUtils.lineToGrid = function(i,w){\r\n    return {\r\n        x: i%w,\r\n        y: Math.floor(i/w)\r\n    }\r\n};\r\n\r\nUtils.tileToPct = function(x,y){\r\n    return {\r\n        x : x / _shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].worldWidth,\r\n        y : y / _shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].worldHeight\r\n    }\r\n};\r\n\r\nUtils.pctToTile = function(x,y){\r\n    return {\r\n        x : x * _shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].worldWidth,\r\n        y : y * _shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].worldHeight\r\n    }\r\n};\r\n\r\nUtils.screenToMap = function(x,y,map){\r\n    var tlx = map.x - map.displayOriginX; // top left of map\r\n    var tly = map.y - map.displayOriginY;\r\n    console.log(x,y,tlx,tly);\r\n    return {\r\n        x: x - tlx,\r\n        y: y - tly\r\n    }\r\n};\r\n\r\n// ### Quadrant-related methods ###\r\n\r\nUtils.AOIcoordinates = function(aoi){\r\n    return {\r\n        x : (aoi%_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal),\r\n        y : Math.floor(aoi/_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal)\r\n    }\r\n};\r\n\r\nUtils.distanceBetweenAOIs = function(A,B){\r\n    return Utils.manhattan(Utils.AOIcoordinates(A),Utils.AOIcoordinates(B));\r\n};\r\n\r\nUtils.tileToQuadrant = function(x,y,quadW,quadH){\r\n    if(!quadW) quadW = 10;\r\n    if(!quadH) quadH = 10;\r\n    var aoi = Utils.tileToAOI({x:x,y:y});\r\n    return Utils.aoiToQuadrant(aoi,quadW,quadH);\r\n};\r\n\r\nUtils.aoiToQuadrant = function(aoi,quadW,quadH){\r\n    var aoiCoords = Utils.lineToGrid(aoi,_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal);\r\n    var nbQuadsHorizontal = Math.ceil(_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal/quadW);\r\n    var top = Math.floor(aoiCoords.y/quadH);\r\n    var left = Math.floor(aoiCoords.x/quadW);\r\n    return (top*nbQuadsHorizontal)+left;\r\n};\r\n\r\nUtils.distanceToPoles = function(x,y,poles){\r\n    var aoi = Utils.tileToAOI({x:x,y:y});\r\n    var aoicoord = Utils.lineToGrid(aoi,_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal);\r\n    var dists = []; // distances (in aoi) between tile and each pole\r\n    var sum = 0;\r\n    for(var i = 0; i < poles.length; i++){\r\n        var d = Utils.euclidean(\r\n            aoicoord,\r\n            Utils.lineToGrid(poles[i],_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal)\r\n        );\r\n        if(d == 0) d = 0.1;\r\n        d *= d; // polarizes more\r\n        sum += d;\r\n        dists.push(d);\r\n    }\r\n    //console.log('distances :', dists, 'sum = ',sum);\r\n\r\n    // Revert: d' = sum/d\r\n    var sumweights = 0;\r\n    var weights = dists.map(function(d){\r\n        //var w = (d > 0 ? sum/d : 1);\r\n        var w = sum/d;\r\n        sumweights += w;\r\n        return w;\r\n    });\r\n    //console.log('weights :', weights);\r\n\r\n    // Normalize: z = d'/sum'\r\n    var normalized = weights.map(function(w){\r\n        var w = Math.round((w/sumweights)*10);\r\n        if(w <= 2) w = 0;\r\n        return w;\r\n    });\r\n    //console.log('normalized :', normalized);\r\n    return normalized;\r\n};\r\n\r\n\r\n// ### General methods ###\r\n\r\nUtils.listAdjacentAOIs = function(current){\r\n    if(!_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal){\r\n        console.log('ERROR : Chunk data not initialized');\r\n        return [];\r\n    }\r\n\r\n    var AOIs = [];\r\n    var isAtTop = (current < _shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal);\r\n    var isAtBottom = (current > _shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].lastChunkID - _shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal);\r\n    var isAtLeft = (current%_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal == 0);\r\n    var isAtRight = (current%_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal == _shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal-1);\r\n    AOIs.push(current);\r\n    if(!isAtTop) AOIs.push(current - _shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal);\r\n    if(!isAtBottom) AOIs.push(current + _shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal);\r\n    if(!isAtLeft) AOIs.push(current-1);\r\n    if(!isAtRight) AOIs.push(current+1);\r\n    if(!isAtTop && !isAtLeft) AOIs.push(current-1-_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal);\r\n    if(!isAtTop && !isAtRight) AOIs.push(current+1-_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal);\r\n    if(!isAtBottom && !isAtLeft) AOIs.push(current-1+_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal);\r\n    if(!isAtBottom && !isAtRight) AOIs.push(current+1+_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nbChunksHorizontal);\r\n    return AOIs;\r\n};\r\n\r\nUtils.listNeighborsInGrid = function(current,width,height,offset){\r\n    offset = (offset || 1);\r\n    var nbh = [current];\r\n    var isAtTop = (current < width);\r\n    var isAtBottom = (current > ((width*height)-1) - width);\r\n    var isAtLeft = (current%width == 0);\r\n    var isAtRight = (current%width == width-1);\r\n    if(!isAtTop) nbh.push(current - width);\r\n    if(!isAtBottom) nbh.push(current + width);\r\n    if(!isAtLeft) nbh.push(current-(1*offset));\r\n    if(!isAtRight) nbh.push(current+(1*offset));\r\n    if(!isAtTop && !isAtLeft) nbh.push(current-(1*offset)-width);\r\n    if(!isAtTop && !isAtRight) nbh.push(current+(1*offset)-width);\r\n    if(!isAtBottom && !isAtLeft) nbh.push(current-(1*offset)+width);\r\n    if(!isAtBottom && !isAtRight) nbh.push(current+(1*offset)+width);\r\n    return nbh;\r\n}\r\n\r\nUtils.formatMoney = function(nb){\r\n    return 'coin'+(nb > 1 ? 's' : '');\r\n};\r\n\r\nUtils.euclidean = function(a,b){\r\n    //console.log('dist between',a,b);\r\n    return Math.sqrt(Math.pow(a.x-b.x,2)+Math.pow(a.y- b.y,2));\r\n};\r\n\r\nUtils.chebyshev = function(A,B){\r\n    return Math.max(Math.abs(A.x-B.x),Math.abs(A.y-B.y));\r\n};\r\n\r\nUtils.nextTo = function(a,b){\r\n    a = a.getRect();\r\n    b = b.getRect();\r\n    return Utils.overlap(a,b,true);\r\n};\r\n\r\nUtils.overlap = function(a,b,touch){\r\n    if(touch){ // touching counts as overlapping\r\n        if(a.x > b.x + b.w || b.x > a.x + a.w) return false;\r\n        if(a.y > b.y + b.h || b.y > a.y + a.h) return false;\r\n    }else{\r\n        if(a.x >= b.x + b.w || b.x >= a.x + a.w) return false;\r\n        if(a.y >= b.y + b.h || b.y >= a.y + a.h) return false;\r\n    }\r\n    return true;\r\n};\r\n\r\nUtils.getBoxCenter = function(box){\r\n    return {\r\n        x: box.x + (box.w/2),\r\n        y: box.y + (box.h/2)\r\n    }\r\n};\r\n\r\nUtils.boxesDistance = function(a,b){\r\n    var ca = Utils.getBoxCenter(a);\r\n    var cb = Utils.getBoxCenter(b);\r\n    var dx = Math.max(0,Math.abs(ca.x-cb.x) - (a.w/2) - (b.w/2));\r\n    var dy = Math.max(0,Math.abs(ca.y-cb.y) - (a.h/2) - (b.h/2));\r\n    //console.warn(dx,dy);\r\n    return dx+dy;\r\n};\r\n\r\n/*Utils.multiChebcomponent = function(A,B,coord,length){\r\n    return Math.min(\r\n        Math.abs(A[coord]-B[coord]),\r\n        Math.abs(A[coord]+A[length]-B[coord]),\r\n        Math.abs(A[coord]-(B[coord]+B[length])),\r\n        Math.abs(A[coord]+A[length]-(B[coord]+B[length]))\r\n    );\r\n};\r\n\r\n// a & b should be rectangles, i.e. expose x, y, w and h\r\nUtils.multiTileChebyshev = function(A,B){\r\n    return Math.max(Utils.multiChebcomponent(A,B,'x','w'),Utils.multiChebcomponent(A,B,'y','h'));\r\n};*/\r\n\r\n// With respect to B\r\nUtils.relativePosition = function(A,B){\r\n    return {\r\n        x: Math.sign(B.x-A.x),\r\n        y: Math.sign(B.y-A.y)\r\n    }\r\n};\r\n\r\nUtils.manhattan = function(a,b){\r\n    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\r\n};\r\n\r\nUtils.multiTileManhattan = function(A,B){\r\n    var dx = Math.min(\r\n        Math.abs(A.x-B.x),\r\n        Math.abs(A.x+A.w-B.x),\r\n        Math.abs(A.x-(B.x+B.w)),\r\n        Math.abs(A.x+A.w-(B.x+B.w))\r\n    );\r\n    var dy = Math.min(\r\n        Math.abs(A.y-B.y),\r\n        Math.abs(A.y+A.h-B.y),\r\n        Math.abs(A.y-(B.y+B.h)),\r\n        Math.abs(A.y+A.h-(B.y+B.h))\r\n    );\r\n    return Math.abs(dx)+Math.abs(dy);\r\n};\r\n\r\nUtils.clamp = function(x,min,max){ // restricts a value to a given interval (return the value unchanged if within the interval\r\n    return Math.max(min, Math.min(x, max));\r\n};\r\n\r\nUtils.randomInt = function(low, high) { // [low, high]\r\n    high++;\r\n    return Math.floor(Math.random() * (high - low) + low);\r\n};\r\n\r\nUtils.randomElement = function(arr){\r\n    return arr[Math.floor(Math.random()*arr.length)];\r\n};\r\n\r\nUtils.randomElementRemoved = function(arr){\r\n    return arr.splice(Math.floor(Math.random()*arr.length),1)[0];\r\n};\r\n\r\nUtils.randomNorm = function(mean,std){ // Returns a value from a normal distribution\r\n    return randomZ()*std+mean;\r\n};\r\n\r\nfunction randomZ() { // Box-Muller transform to return a random value from a reduced normal\r\n    var u = 0, v = 0;\r\n    while(u === 0) u = Math.random(); //Converting [0,1) to (0,1)\r\n    while(v === 0) v = Math.random();\r\n    return Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );\r\n}\r\n\r\nUtils.swapElements = function(arr,b,c){\r\n    var tmp = arr[b];\r\n    arr[b] = arr[c];\r\n    arr[c] = tmp;\r\n};\r\n\r\nUtils.removeElement = function(v,arr){\r\n    var idx = arr.indexOf(v);\r\n    if(idx > -1) arr.splice(idx,1);\r\n};\r\n\r\nUtils.insert = function(a1,a2,pos){ // insert array a2 at position pos in array a1\r\n    a1.splice.apply(a1, [pos, 0].concat(a2));\r\n};\r\n\r\nUtils.shuffle = function(array) {\r\n    for (var i = array.length - 1; i > 0; i--) {\r\n        var j = Math.floor(Math.random() * (i + 1));\r\n        var temp = array[i];\r\n        array[i] = array[j];\r\n        array[j] = temp;\r\n    }\r\n};\r\n\r\nUtils.indexOfMax = function(arr) {\r\n    if (arr.length === 0) return -1;\r\n    var max = arr[0];\r\n    var maxIndex = 0;\r\n    for (var i = 1; i < arr.length; i++) {\r\n        if (arr[i] > max) {\r\n            maxIndex = i;\r\n            max = arr[i];\r\n        }\r\n    }\r\n    return maxIndex;\r\n};\r\n\r\nUtils.printArray = function(arr){\r\n    console.log(JSON.stringify(arr));\r\n};\r\n\r\nUtils.capitalizeFirstLetter = function(string) {\r\n    return string.charAt(0).toUpperCase() + string.slice(1);\r\n};\r\n\r\nfunction coordinatesPairToTile(coords){\r\n    return {\r\n        x: Math.floor(coords.x/_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].tileWidth),\r\n        y: Math.floor(coords.y/_shared_World__WEBPACK_IMPORTED_MODULE_0__[\"default\"].tileHeight)\r\n    }\r\n}\r\n\r\nfunction coordinatesToCell(v,grid){\r\n    return Math.floor(v/grid);\r\n}\r\n\r\nUtils.computeSpeed = function(angle){ // return unit speed vector given an angle\r\n    return {\r\n        x: Math.cos(angle),\r\n        y: -Math.sin(angle)\r\n    }\r\n};\r\n\r\nArray.prototype.diff = function(a) { // returns the elements in the array that are not in array a\r\n    return this.filter(function(i) {return a.indexOf(i) < 0;});\r\n};\r\n\r\nArray.prototype.last = function(){\r\n    return this[this.length-1];\r\n};\r\n\r\nArray.prototype.rotate = function( n ) {\r\n    this.unshift.apply( this, this.splice( n, this.length ) );\r\n    return this;\r\n};\r\n\r\nArray.prototype.previous = function(i){\r\n    return (i > 0 ? this[i-1] : this.last());\r\n};\r\n\r\nif (typeof Object.assign !== 'function') {\r\n    // Must be writable: true, enumerable: false, configurable: true\r\n    Object.defineProperty(Object, \"assign\", {\r\n        value: function assign(target, varArgs) { // .length of function is 2\r\n            'use strict';\r\n            if (target === null || target === undefined) {\r\n                throw new TypeError('Cannot convert undefined or null to object');\r\n            }\r\n\r\n            var to = Object(target);\r\n\r\n            for (var index = 1; index < arguments.length; index++) {\r\n                var nextSource = arguments[index];\r\n\r\n                if (nextSource !== null && nextSource !== undefined) {\r\n                    for (var nextKey in nextSource) {\r\n                        // Avoid bugs when hasOwnProperty is shadowed\r\n                        if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\r\n                            to[nextKey] = nextSource[nextKey];\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return to;\r\n        },\r\n        writable: true,\r\n        configurable: true\r\n    });\r\n}\r\n\r\n// if (onServer) module.exports.Utils = Utils;\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (Utils);\n\n//# sourceURL=webpack:///./shared/Utils.js?");

/***/ }),

/***/ "./shared/World.js":
/*!*************************!*\
  !*** ./shared/World.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\r\n * Created by Jerome on 14-10-17.\r\n */\r\n\r\nvar World = {};\r\n\r\nWorld.setUp = function(nbHoriz,nbVert,chunkW,chunkH,tileW,tileH){\r\n    World.nbChunksHorizontal = nbHoriz;\r\n    World.nbChunksVertical = nbVert;\r\n    World.chunkWidth = chunkW;\r\n    World.chunkHeight = chunkH;\r\n    World.tileWidth = tileW || 32;\r\n    World.tileHeight = tileH || 32;\r\n    World.computeProperties();\r\n};\r\n\r\nWorld.readMasterData = function(data){\r\n    World.setUp(\r\n        data.nbChunksHoriz,data.nbChunksVert,\r\n        data.chunkWidth,data.chunkHeight\r\n    );\r\n};\r\n\r\nWorld.computeProperties = function(){\r\n    World.worldWidth = World.chunkWidth*World.nbChunksHorizontal;\r\n    World.worldHeight = World.chunkHeight*World.nbChunksVertical;\r\n    World.lastChunkID = World.nbChunksHorizontal*World.nbChunksVertical - 1;\r\n    console.log('Set up world of size '+World.worldWidth+' x '+World.worldHeight);\r\n};\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (World);\n\n//# sourceURL=webpack:///./shared/World.js?");

/***/ }),

/***/ "./tools/Geometry.js":
/*!***************************!*\
  !*** ./tools/Geometry.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\r\n * Created by Jerome on 03-08-17.\r\n */\r\n\r\nvar onServer = (typeof window === 'undefined');\r\n\r\nif(onServer){\r\n    var Utils = __webpack_require__(/*! ../shared/Utils.js */ \"./shared/Utils.js\").Utils;\r\n}\r\n\r\nvar Geometry = {\r\n    lastrectID : 0, // running id of generated rects\r\n    colors : {\r\n        0: 0xff0000,\r\n        1: 0x00ff00,\r\n        2: 0x0000ff,\r\n        3: 0xffff00\r\n    }\r\n};\r\n\r\n// Generates a Gaussian cluster of elements (e.g. trees)\r\nGeometry.cluster = function(x,y){\r\n    var pts = [];\r\n    var stdX = document.getElementById('w').value;\r\n    var stdY = document.getElementById('h').value;\r\n    var n = document.getElementById('n').value;\r\n    var exclude = [];\r\n    for(var i = 0; i < n; i++){\r\n        var pt = {\r\n            x: Math.round(randomNorm(x,stdX)),\r\n            y: Math.round(randomNorm(y,stdY))\r\n        };\r\n        if(Geometry.containsPt(exclude,pt)){\r\n            i--;\r\n            continue;\r\n        }\r\n        pts.push(pt);\r\n        for(var e = -3; e < 3; e++){\r\n            exclude.push({x:pt.x+e,y:pt.y});\r\n        }\r\n    }\r\n    printArray(pts);\r\n    return pts;\r\n};\r\n\r\nGeometry.containsPt = function(pts,pt){\r\n    for(var i = 0; i < pts.length; i++){\r\n        if(pts[i].x == pt.x && pts[i].y == pt.y) return true;\r\n    }\r\n    return false;\r\n};\r\n\r\nGeometry.makeCorona = function(x,y,w,h){\r\n    //var height = document.getElementById('w').value;\r\n    //var width = document.getElementById('h').value;\r\n    var width = w;\r\n    var height = h;\r\n    var start = {\r\n        x: x,\r\n        y: y-height\r\n    };\r\n    var pts = [start];\r\n    Geometry.coronaSide(pts,-1,1,pts[pts.length-1],width,height);\r\n    Geometry.coronaSide(pts,1,1,pts[pts.length-1],width,height);\r\n    Geometry.coronaSide(pts,1,-1,pts[pts.length-1],width,height);\r\n    Geometry.coronaSide(pts,-1,-1,pts[pts.length-1],width,height);\r\n    //printArray(pts);\r\n    pts.pop();\r\n    return pts;\r\n};\r\n\r\nGeometry.coronaSide = function(pts,xstep,ystep,pt,width,height){\r\n    var initW = width;\r\n    var initH = height;\r\n    var refDimension = (xstep == ystep ? height : width);\r\n    var max = Math.ceil(refDimension/2);\r\n    var nbSegments = Utils.randomInt(2,max);\r\n    var alt = +(xstep != ystep);\r\n\r\n    for(var i = 0; i < nbSegments; i++){\r\n        var upperLimitW = Math.min(width-(nbSegments-i),Math.ceil(initW/3));\r\n        var upperLimitH = Math.min(height-(nbSegments-i),Math.ceil(initH/3));\r\n        var xlength = (i == nbSegments-1 ? width : Utils.randomInt(1,upperLimitW+1));\r\n        var ylength = (i == nbSegments-1 ? height : Utils.randomInt(1,upperLimitH+1));\r\n        width-=xlength;\r\n        height-=ylength;\r\n\r\n        pts.push({\r\n            x: pts[pts.length-1].x + xlength*xstep*alt,\r\n            y: pts[pts.length-1].y + ylength*ystep*(1-alt)\r\n        });\r\n        pts.push({\r\n            x: pts[pts.length-1].x + xlength*xstep*(1-alt),\r\n            y: pts[pts.length-1].y + ylength*ystep*alt\r\n        });\r\n    }\r\n};\r\n\r\nGeometry.makePxCoords = function(pt){\r\n    return {\r\n        x: pt.x * Engine.tileWidth,\r\n        y: pt.y * Engine.tileHeight\r\n    }\r\n};\r\n\r\nGeometry.straightLine = function(start,end){\r\n    if(isNaN(end.x) || isNaN(end.y)) console.log('WARNING: Not numbers!');\r\n    var tileWidth = 32;\r\n    var tileHeight = 32;\r\n    var step = 32;\r\n    var speed = Geometry.computeSpeedVector(Geometry.computeAngle(start,end,false)); // false: not degrees\r\n    var tile = {\r\n        x: start.x,\r\n        y: start.y\r\n    };\r\n    var tmp = {\r\n        x: start.x*tileWidth,\r\n        y: start.y*tileHeight\r\n    };\r\n    var lastDist = Geometry.euclidean(tile,end);\r\n    var tiles = [tile];\r\n    while(tile.x != end.x || tile.y != end.y){\r\n        tmp.x += speed.x*step;\r\n        tmp.y += speed.y*step;\r\n        tile = {\r\n            x: Math.floor(tmp.x/tileWidth),\r\n            y: Math.floor(tmp.y/tileHeight)\r\n        };\r\n        //console.log(tile);\r\n        //console.log(tiles[tiles.length-1]);\r\n        if(tile.x == tiles[tiles.length-1].x && tile.y == tiles[tiles.length-1].y) continue;\r\n        var newDist = Geometry.euclidean(tile,end);\r\n        if(newDist > lastDist) break;\r\n        tiles.push(tile);\r\n        lastDist = newDist;\r\n    }\r\n    return tiles;\r\n};\r\n\r\nGeometry.addCorners = function(tiles){ // Add corners to a straight line to follow tiles grid\r\n    for(var i = 0; i < tiles.length-1; i++){\r\n        var t = tiles[i];\r\n        var next = tiles[i+1];\r\n        var dx = next.x - t.x;\r\n        var dy = next.y - t.y;\r\n        if(Math.abs(dx) + Math.abs(dy) == 1) continue;\r\n        var p = {x:t.x,y:t.y};\r\n        if(dx == -1 && dy == 1) p.x--; // BL\r\n        if(dx == 1 && dy == 1) p.x++; // BR\r\n        if(dx == -1 && dy == -1) p.x--; // TL\r\n        if(dx == 1 && dy == -1) p.x++; // TR\r\n        tiles.splice(i+1,0,p);// insert new point\r\n        i++;\r\n    }\r\n    return tiles;\r\n};\r\n\r\n// Smoothes a shape obtained from a SVG path\r\nGeometry.forwardSmoothPass = function(tiles){\r\n    for(var i = 0; i < tiles.length-1; i++){\r\n        var t = tiles[i];\r\n        var next = tiles[i+1];\r\n        var dx = next.x - t.x;\r\n        var dy = next.y - t.y;\r\n        if(dx == 1 && dy == 1){ // angle bottom-right\r\n            tiles.splice(i+1,0,{\r\n                x: t.x,\r\n                y: t.y+1\r\n            });\r\n            i++;\r\n        }\r\n        if(dx == 1 && dy == -1){ // angle top-right\r\n            tiles.splice(i+1,0,{\r\n                x: t.x+1,\r\n                y: t.y\r\n            });\r\n            i++;\r\n        }\r\n        if(dx == -1 && dy == 1){ // angle bottom-left\r\n            tiles.splice(i+1,0,{\r\n                x: t.x,\r\n                y: t.y+1\r\n            });\r\n            i++;\r\n        }\r\n        if(dx == -1 && dy == -1){ // angle top-left\r\n            tiles.splice(i+1,0,{\r\n                x: t.x-1,\r\n                y: t.y\r\n            });\r\n            i++;\r\n        }\r\n        if(dx == 2 && dy == 0){ // horizontal gap\r\n            tiles.splice(i+1,0,{\r\n                x: t.x+1,\r\n                y: t.y\r\n            });\r\n            i++;\r\n        }\r\n        if(dx == 0 && dy == 2){ // vertical gap\r\n            tiles.splice(i,1); // simply remove it\r\n        }\r\n    }\r\n    return tiles;\r\n};\r\n\r\nGeometry.backwardSmoothPass = function(tiles){         // Backward loop to remove tiles ; goes clockwise\r\n    for(var i = tiles.length-1; i >= 0; i--){\r\n        var t = tiles[i];\r\n        //var bnf = false; // back and forth between tiles\r\n        for(var j = 1; j < Math.min(7,tiles.length+1); j++){ // knots & duplicates\r\n            var idx = i + j;\r\n            if(idx > tiles.length-1) idx -= tiles.length;\r\n            var old= tiles[idx];\r\n            if(t.x == old.x && t.y == old.y) tiles.splice(i+1,j); // remove j points corresponding to size of knot\r\n            //if(Math.abs(t.y - old.y) > j) bnf = true;\r\n        }\r\n        //if(bnf) tiles.splice(i,1);\r\n    }\r\n    return tiles;\r\n};\r\n\r\nGeometry.removeFringeTiles = function(tiles,worldWidth,worldHeight){\r\n    for(var i = 0; i < tiles.length; i++){\r\n        var tile = tiles[i];\r\n        //if(tile.x == 0 || tile.x == worldWidth || tile.y == 0 || tile.y == worldHeight) count++;\r\n        if(tile.x == 0) tile.x = -1;\r\n        if(tile.y == 0) tile.y = -1;\r\n        if(tile.x == worldWidth) tile.x++;\r\n        if(tile.y == worldHeight) tile.y++;\r\n    }\r\n    return tiles;\r\n};\r\n\r\nGeometry.makePoint = function(x,y){\r\n    return new PIXI.Point(x*Engine.tileWidth,y*Engine.tileHeight);\r\n};\r\n\r\nGeometry.makePolyrect = function(worldx,worldy){\r\n    var N = 1; // test with n = 5;\r\n    var rects = [];\r\n    Geometry.randomRects(rects,worldx,worldy,N,true);\r\n    var pts = Geometry.mergeRects(rects);\r\n    var centroid = Geometry.computeCentroid(pts);\r\n    //Engine.drawCircle(centroid.x,centroid.y,3,0x000000);\r\n    Geometry.sortPoints(pts,centroid);\r\n    //Engine.drawCircle(pts[0].x,pts[0].y,4,0xff00ff);\r\n    Geometry.smoothShape(pts);\r\n    Geometry.smoothShape(pts); // two passes\r\n    return pts;\r\n};\r\n\r\nGeometry.randomRects = function(rects,worldx,worldy,N,randomRects){\r\n    if(randomRects) {\r\n        for (var i = 0; i < N; i++) {\r\n            /*var x = (worldx + randomInt(-5, 6)) * Engine.tileWidth;\r\n            var y = (worldy + randomInt(-5, 6)) * Engine.tileHeight;\r\n            var w = randomInt(3, 10) * Engine.tileWidth;\r\n            var h = randomInt(3, 10) * Engine.tileHeight;*/\r\n            var x = (worldx + randomInt(-5, 6));\r\n            var y = (worldy + randomInt(-5, 6));\r\n            var w = randomInt(3, 10);\r\n            var h = randomInt(3, 10);\r\n            rects.push(new Rect(x, y, w, h));\r\n            //console.log(JSON.stringify(rects[rects.length - 1]));\r\n        }\r\n    }else {\r\n        var rectID = 3;\r\n        switch(rectID){\r\n            case 0:\r\n                rects.push(new Rect(worldx * 32, worldy * 32, 128, 256));\r\n                rects.push(new Rect((worldx * 32) - 192, (worldy * 32) + 128, 192, 128));\r\n                rects.push(new Rect((worldx * 32) + 128, (worldy * 32) + 128, 192, 288));\r\n                break;\r\n            case 1:\r\n                rects.push(new Rect(1024,288+64,288,288));\r\n                rects.push(new Rect(992,448+64,224,96));\r\n                rects.push(new Rect(1056,288+64, 192, 256));\r\n                break;\r\n            case 2:\r\n                rects.push(new Rect(1024,512+64,224,288));\r\n                rects.push(new Rect(1088,320+64,160,128));\r\n                rects.push(new Rect(832,352+64,128,160));\r\n                break;\r\n            case 3:\r\n                rects.push(new Rect(800,320+416,160,192));\r\n                rects.push(new Rect(1088,320+416,224,224));\r\n                rects.push(new Rect(896,384+416,288,224));\r\n                break;\r\n            case 4:\r\n                rects.push(new Rect(928-64,416,160,192));\r\n                rects.push(new Rect(1056-64,448,96,256));\r\n                rects.push(new Rect(1056-64 ,640,192,256));\r\n                break;\r\n            case 5:\r\n                rects.push(new Rect(1088,384,256,288));\r\n                rects.push(new Rect(1024,576,128,288));\r\n                rects.push(new Rect(1088,288,192,128));\r\n                break;\r\n        }\r\n    }\r\n};\r\n\r\n// Given a list of rectangles, remove the vertices that are located within other rectangles, compute intersections and\r\n// return a single shape (as a list of vertices)\r\nGeometry.mergeRects = function(rects){\r\n    var queue = [];\r\n    var pts = [];\r\n    // Merge the vertices of all rects in a single list\r\n    for(var i = 0; i < rects.length; i++){\r\n        queue = queue.concat(rects[i].points);\r\n    }\r\n    while(queue.length > 0){\r\n        var overlap = false;\r\n        var pt = queue.shift();\r\n        for(var i = 0; i < rects.length; i++){\r\n            var rect = rects[i];\r\n            if(pt.rectID == rect.id) continue;\r\n            if(rect.contains(pt)){\r\n                overlap = true;\r\n                queue = queue.concat(rect.findIntersects(rect));\r\n                break;\r\n            }\r\n        }\r\n        if(!overlap) pts.push(pt);\r\n    }\r\n    return Geometry.removeDuplicates(pts);\r\n};\r\n\r\n// Remove duplicate vertices having arised from merging rectangles\r\nGeometry.removeDuplicates = function(pts){\r\n    return pts.reduce(function (p, c) {\r\n        // create an identifying id from the object values\r\n        var id = [c.x, c.y].join('|');\r\n        // if the id is not found in the temp array\r\n        // add the object to the output array\r\n        // and add the key to the temp array\r\n        if (p.temp.indexOf(id) === -1) {\r\n            p.out.push(c);\r\n            p.temp.push(id);\r\n        }\r\n        return p;\r\n        // return the deduped array\r\n    }, { temp: [], out: [] }).out;\r\n};\r\n\r\nGeometry.computeCentroid = function(pts){\r\n    var sumx = 0;\r\n    var sumy = 0;\r\n    for(var i = 0; i < pts.length; i++){\r\n        sumx += pts[i].x;\r\n        sumy += pts[i].y;\r\n    }\r\n    sumx = sumx/pts.length;\r\n    sumy = sumy/pts.length;\r\n    return new PIXI.Point(sumx,sumy);\r\n};\r\n\r\nGeometry.sortPoints = function(pts,centroid){\r\n    for(var i = 0; i < pts.length;i++){\r\n        pts[i].x -= centroid.x;\r\n        pts[i].y -= centroid.y;\r\n    }\r\n    pts.sort(Geometry.sortAngle);\r\n    for(var i = 0; i < pts.length;i++){\r\n        pts[i].x += centroid.x;\r\n        pts[i].y += centroid.y;\r\n    }\r\n};\r\n\r\n// Sort points in anti-clockwise order\r\nGeometry.sortAngle = function(a,b){\r\n    var origin = {x:0,y:0};\r\n    var aa = Geometry.computeAngle(a, origin,true);\r\n    var bb = Geometry.computeAngle(b, origin,true);\r\n    if(aa > bb) return 1;\r\n    if(aa < bb) return -1;\r\n    // If ame angle, sort based on proxiity\r\n    var ea = Geometry.euclidean(a,origin);\r\n    var eb = Geometry.euclidean(b,origin);\r\n    var sign = aa/Math.abs(aa);\r\n    if(aa == -90) sign = 1;\r\n    if(aa == 0) sign = -1;\r\n    if(ea > eb) return 1*sign;\r\n    if(ea < eb) return -1*sign;\r\n    return 0;\r\n};\r\n\r\nGeometry.smoothShape = function(pts){\r\n    for(var i = 0; i < pts.length; i++){\r\n        var b = (i+1 < pts.length ? i+1 : i+1-pts.length);\r\n        var c = (i+2 < pts.length ? i+2 : i+2-pts.length);\r\n        var d = (i+3 < pts.length ? i+3 : i+3-pts.length);\r\n        var angle = Geometry.computeAngle(pts[i],pts[b],true);\r\n        var angle2 = Geometry.computeAngle(pts[i],pts[c],true);\r\n        if(angle == angle2){ // straight line, remove intermediate point\r\n            pts.splice(b,1);\r\n        }else if((angle%45 != 0 && angle2%45 == 0)) { // swap to points\r\n            swapElements(pts,b,c);\r\n        }else if(angle%90 == 0 && angle2%90 == 0 && angle != angle2){ // swap to points to remove triangle\r\n            swapElements(pts,c,d);\r\n        }else if(angle%45 == 0 && angle2%90 == 0 && angle != angle2){ // swap two points to remove spike\r\n            swapElements(pts,b,c);\r\n        }else if((angle%45 != 0 && angle2%45 != 0)) { // create an angle\r\n            pts.splice(b,0,new PIXI.Point(pts[i].x,pts[b].y));\r\n        }\r\n    }\r\n};\r\n\r\n// Create the points corresponding to tiles between vertices of a shape\r\nGeometry.interpolatePoints = function(pts){\r\n    for(var i = 0; i < pts.length; i++) {\r\n        var next = (i == pts.length - 1 ? 0 : i + 1);\r\n        var dx = (pts[next].x - pts[i].x);\r\n        var dy = (pts[next].y - pts[i].y);\r\n        // j used for positioning new points, k for counting them and managing position in array\r\n        for(var j = 1, k = 1; j < Math.max(Math.abs(dx),Math.abs(dy)); j++, k++){\r\n            pts.splice(i+k,0,{\r\n                x: pts[i].x + (j*(dx/Math.abs(dx)) || 0),\r\n                y: pts[i].y + (j*(dy/Math.abs(dy)) || 0)\r\n            });// insert new point\r\n        }\r\n        i += k-1;\r\n    }\r\n    return pts;\r\n};\r\n\r\nGeometry.euclidean = function(a,b){\r\n    return Math.pow(a.x-b.x,2)+Math.pow(a.y- b.y,2);\r\n};\r\n\r\nGeometry.manhattan = function(a,b){\r\n    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\r\n};\r\n\r\nGeometry.computeAngle = function(a,b,degrees){ // return angle between points a and b\r\n    var angle = -(Math.atan2(b.y- a.y, b.x- a.x));\r\n    if(degrees) { // returns in degrees instead\r\n        angle *= (180/Math.PI);\r\n        if(angle == -180) angle*= -1;\r\n    }\r\n    return angle;\r\n};\r\n\r\nGeometry.computeSpeedVector = function(angle){ // return unit speed vector given an angle\r\n    return {\r\n        x: Math.cos(angle),\r\n        y: -Math.sin(angle)\r\n    }\r\n};\r\n\r\n// Rects to polygon code (legacy from fog of war)\r\n\r\nfunction Pt(x,y){\r\n    this.x = x;\r\n    this.y = y;\r\n    this.c = 1; // count\r\n    this.nbors = [];\r\n}\r\n\r\nPt.prototype.link = function(pt){\r\n    this.nbors.push(pt);\r\n};\r\n\r\nPt.prototype.unlink = function(pt){\r\n    var idx = this.nbors.findIndex(function(e){\r\n        return (e.x == pt.x && e.y == pt.y);\r\n    });\r\n    this.nbors.splice(idx,1);\r\n};\r\n\r\nPt.prototype.equal = function(pt){\r\n    if(pt === null) return false;\r\n    return (this.x == pt.x && this.y == pt.y);\r\n};\r\n\r\nPt.prototype.ts = function(){\r\n    return \"(\"+this.x+\",\"+this.y+\")\";\r\n};\r\n\r\nPt.prototype.debug = function(){\r\n    console.log(this.ts(),\"has\",this.nbors.length,\"neighbors and a count of\",this.c);\r\n};\r\n\r\nfunction link(pts){ // link together all points in list\r\n    for(var i = 0; i < pts.length; i++){\r\n        for(var j = i; j < pts.length; j++){\r\n            var a = pts[i];\r\n            var b = pts[j];\r\n            var dx = Math.abs(a.x-b.x);\r\n            var dy = Math.abs(a.y-b.y);\r\n            if( dx ? !dy : dy ) { // xor, equivalent to avoiding diagonals\r\n                //console.log(\"Linking\",a.ts(),\"to\",b.ts());\r\n                a.link(b);\r\n                b.link(a);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction unlink(pt){ // unlink a point from all its neighbors\r\n    pt.nbors.forEach(function(nb){\r\n        nb.unlink(pt);\r\n    });\r\n}\r\n\r\nfunction lint(pts){ // remove side-by-side duplicate neighbors\r\n    for(var i = pts.length-2; i >= 0; i--){\r\n        if(i == pts.length-1) continue; // needed when there are 4 duplicates in a row\r\n        if(pts[i].equal(pts[i+1])){\r\n            pts.splice(i+1,1);\r\n            pts.splice(i,1);\r\n        }\r\n    }\r\n}\r\n\r\nfunction rectsToPoly(aois){\r\n    var space = new SpaceMap();\r\n    aois.forEach(function(aoi){\r\n        var corners = Utils.getAOIcorners(aoi);\r\n        var pts = [];\r\n        corners.forEach(function(corner){\r\n            var pt = space.get(corner.x,corner.y);\r\n            if(pt){\r\n                pt.c++;\r\n            }else{\r\n                pt = new Pt(corner.x,corner.y);\r\n                space.add(pt.x,pt.y,pt);\r\n            }\r\n            pts.push(pt);\r\n        });\r\n        link(pts);\r\n    });\r\n\r\n    /*space.toList().forEach(function(pt){\r\n        pt.v.debug();\r\n    });*/\r\n\r\n    space.toList().forEach(function(entry){\r\n        var pt = entry.v;\r\n        if(pt.c%2 == 0){ // redundant points have the property of having even counts\r\n            unlink(pt);\r\n            link(pt.nbors);\r\n            space.delete(pt.x,pt.y);\r\n        }\r\n    });\r\n\r\n    var l = space.toList();\r\n    l.forEach(function(entry){\r\n        var pt = entry.v;\r\n        lint(pt.nbors);\r\n    });\r\n\r\n    var s = space.getFirst();\r\n    var path = [s];\r\n    var i = 0;\r\n    while(true){\r\n        if(i > 10000) break; //TODO: remove\r\n        var pt = path[0];\r\n        var pv = null;\r\n        if(path.length > 1) pv = path[1];\r\n        var nt = null;\r\n        for(var j = 0; j < pt.nbors.length; j++){ // Find next neighbor to travel to\r\n            var nb = pt.nbors[j];\r\n            if(!nb.equal(pv)){\r\n                nt = nb;\r\n                break;\r\n            }\r\n        }\r\n        //if(nt === null) console.warn('no next for pt',pt.x,pt.y);\r\n        if(nt.equal(s)) break;\r\n        path.unshift(nt);\r\n        i++;\r\n    }\r\n\r\n    return path;\r\n}\r\n\r\n\r\nif (onServer) module.exports.Geometry = Geometry;\n\n//# sourceURL=webpack:///./tools/Geometry.js?");

/***/ }),

/***/ "./tools/autopath.js":
/*!***************************!*\
  !*** ./tools/autopath.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\r\n * Created by Jerome Renaux (jerome.renaux@gmail.com) on 23-01-19.\r\n */\r\n\r\nvar fs = __webpack_require__(/*! fs */ \"fs\");\r\nvar path = __webpack_require__(/*! path */ \"path\");\r\nvar Jimp = __webpack_require__(/*! jimp */ \"jimp\");\r\nvar SpaceMap = __webpack_require__(/*! ../shared/SpaceMap.js */ \"./shared/SpaceMap.js\").SpaceMap;\r\nvar Geometry = __webpack_require__(/*! ./Geometry.js */ \"./tools/Geometry.js\").Geometry;\r\n\r\nfunction Px(x,y){\r\n    this.x = x;\r\n    this.y = y;\r\n}\r\n\r\nPx.prototype.neighbors = function*(skipDiag){\r\n    for(var i = 0; i < contour.length; i++) {\r\n        var c = {x: contour[i][0], y: contour[i][1]};\r\n        if(skipDiag && c.x != 0 && c.y != 0) continue;\r\n        yield {x:this.x + c.x,y:this.y + c.y};\r\n    }\r\n};\r\n\r\nPx.prototype.clockwiseMoore = function*(image,sdir) {\r\n    var moore = [[-1,0],[-1,-1],[0,-1],[1,-1],[1,0],[1,1], [0,1],[-1,1]];\r\n    var idx = moore.findIndex(function(e){\r\n        return (e[0] == sdir[0] && e[1] == sdir[1]);\r\n    });\r\n    if(idx == -1) console.warn('WARNING: direction not found');\r\n    moore = moore.rotate(idx+1);\r\n    for(var i = 0; i < moore.length; i++){\r\n        var c = {x:moore[i][0],y:moore[i][1]};\r\n        var p = {x:this.x+c.x,y:this.y+c.y};\r\n        if(p.x < 0 || p.y < 0 || p.x >= image.bitmap.width || p.y >= image.bitmap.height) continue;\r\n        var c_ = {x:moore.previous(i)[0],y:moore.previous(i)[1]};\r\n        var p_ = {x:this.x+c_.x,y:this.y+c_.y};\r\n        var dir = [p.x-p_.x,p.y-p_.y];\r\n        yield {p:new Px(p.x,p.y),dir:dir};\r\n    }\r\n};\r\n\r\nPx.prototype.getFirstWhiteNbr = function(image){\r\n    for(var nbr of this.neighbors(true)){\r\n        if(nbr.x < 0 || nbr.y < 0 || nbr.x >= image.bitmap.width || nbr.y >= image.bitmap.height) continue;\r\n        if(image.getPixelColor(nbr.x, nbr.y) == 4294967295) return new Px(nbr.x,nbr.y);\r\n    }\r\n    return null;\r\n};\r\n\r\nPx.prototype.toList = function(){\r\n    return [this.x,this.y];\r\n};\r\n\r\nvar contour = [[-1,0],[-1,-1],[0,-1],[1,-1],[1,0],[1,1], [0,1],[-1,1]];\r\nvar explored = new SpaceMap();\r\n\r\nfunction isBlack(image,x,y){\r\n    return (image.getPixelColor(x, y) != 4294967295) // == 255;\r\n}\r\n\r\nfunction isWhite(image,x,y){\r\n    return (image.getPixelColor(x, y) == 4294967295);\r\n}\r\n\r\nfunction isExplored(x,y){\r\n    return explored.has(x,y);\r\n}\r\n\r\nfunction hasWhiteNb(image,x,y,diags){\r\n    for(var i = 0; i < contour.length; i++){\r\n        var c = {x:contour[i][0],y:contour[i][1]};\r\n        if(!diags && Math.abs(c.x + c.y) != 1) continue; // skip diagonals\r\n        // console.log(x+c.x,y+c.y,image.getPixelColor(x+c.x, y+c.y));\r\n        if(isWhite(image,x+c.x, y+c.y)) return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nfunction readImage(blueprint,cb){\r\n    Jimp.read(path.join('tools','blueprints',blueprint), function (err, image) {\r\n        if (err) throw err;\r\n        cb(image);\r\n    });\r\n}\r\n\r\nfunction getContours(image) {\r\n    console.log('Getting contour ...');\r\n    // console.trace();\r\n    var lines = [];\r\n    for (var x = 0; x < image.bitmap.width; x++) {\r\n        for (var y = 0; y < image.bitmap.height; y++) {\r\n            if (isBlack(image, x, y) && hasWhiteNb(image, x, y,false) && !isExplored(x, y)) {\r\n                // console.warn('starting at',x,y);\r\n                var path = trace(image, x, y);\r\n                // console.log(path);\r\n                if (path && path.length > 2)lines.push(getSegments(path));\r\n            }\r\n        }\r\n    }\r\n    return lines;\r\n}\r\n\r\nfunction trace(image,x,y){\r\n    // Travel along neighbors until meeting start node or image boundaries\r\n    //http://www.imageprocessingplace.com/downloads_V3/root_downloads/tutorials/contour_tracing_Abeer_George_Ghuneim/moore.html    explored.add(x,y);\r\n    var B = []; // boundary\r\n    var s = new Px(x,y); // start\r\n    B.push([x,y]);\r\n    var p = new Px(x,y); //current boundary pixel\r\n    var on = p.getFirstWhiteNbr(image); // backtracked white px from p\r\n    // console.log('now on',on);\r\n    // var dir = {x:on.x-p.x,y:on.y-p.y};\r\n    var dir = [on.x-p.x,on.y-p.y];\r\n    var stop = false;\r\n    while(true){\r\n        // console.log('Swiping around',p,'from dir',dir);\r\n        var exhausted = true;\r\n        for(var step of p.clockwiseMoore(image,dir)){\r\n            on.x = step.p.x;\r\n            on.y = step.p.y;\r\n            // if(isExplored(on.x,on.y)) return [];\r\n            // console.log('now on',on);\r\n            // TODO: Jacob's stopping criterion?\r\n            if(isBlack(image,on.x,on.y)){\r\n                if(isNaN(step.dir[0]) || isNaN(step.dir[1])) console.warn('WARNING: NaN direction');\r\n                // console.log(on,'is black, entered from',step.dir);\r\n                B.push([on.x,on.y]);\r\n                explored.add(on.x,on.y);\r\n                p = new Px(on.x,on.y);\r\n                // dir = step.dir;\r\n                dir[0] = (step.dir[0] == 0 ? 0 : -step.dir[0]);\r\n                dir[1] = (step.dir[1] == 0 ? 0 : -step.dir[1]);\r\n                exhausted = false;\r\n                if(on.x == x && on.y == y) stop = true;\r\n                break;\r\n            }\r\n        }\r\n        if(stop || exhausted) break;\r\n    }\r\n    // console.log(B);\r\n    return B;\r\n}\r\n\r\n/*function addLine(c,p,lines){\r\n    var q = new Px(p.x,p.y);\r\n    // if(q.x > c.x) q.x++;\r\n    // if(q.y > c.y) q.y++;\r\n    // lines.push([c,q]);\r\n    lines.push(q.toList());\r\n}*/\r\n\r\nfunction getSegments(path){\r\n    var c = path[0];\r\n    var lines = [c];\r\n    var bearing = undefined;\r\n    for(var i = 0; i < path.length; i++){\r\n        var p = path[i];\r\n        if(p[0] == c[0] && p[1] == c[1]) continue;\r\n        var dir = Geometry.computeAngle({x:p[0],y:p[1]},{x:c[0],y:c[1]});\r\n        if(bearing == undefined) bearing = dir;\r\n        // console.log(p,c,dir,bearing);\r\n        if(bearing != dir){\r\n            // addLine(c,path[i-1],lines);\r\n            lines.push(path[i-1]);\r\n            c = path[i-1];\r\n            bearing = undefined;\r\n            i--;\r\n        }\r\n    }\r\n    //addLine(c,path[path.length-1],lines);\r\n    lines.push(path.last());\r\n    // console.log(lines);\r\n    return lines;\r\n}\r\n\r\n// readImage('test.png').then(getContours);\r\n\r\nmodule.exports.getContours = getContours;\r\nmodule.exports.readImage = readImage;\r\n\r\n\n\n//# sourceURL=webpack:///./tools/autopath.js?");

/***/ }),

/***/ "./tools/worldMaker.js":
/*!*****************************!*\
  !*** ./tools/worldMaker.js ***!
  \*****************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _shared_Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/Utils */ \"./shared/Utils.js\");\n/* harmony import */ var _shared_World__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/World */ \"./shared/World.js\");\n/**\r\n * Created by Jerome Renaux (jerome.renaux@gmail.com) on 16-12-18.\r\n */\r\nvar fs = __webpack_require__(/*! fs */ \"fs\");\r\nvar path = __webpack_require__(/*! path */ \"path\");\r\nvar Jimp = __webpack_require__(/*! jimp */ \"jimp\");\r\nvar rwc = __webpack_require__(/*! random-weighted-choice */ \"random-weighted-choice\");\r\nvar quickselect = __webpack_require__(/*! quickselect */ \"quickselect\");\r\n\r\nvar SpaceMap = __webpack_require__(/*! ../shared/SpaceMap.js */ \"./shared/SpaceMap.js\").SpaceMap;\r\nvar Geometry = __webpack_require__(/*! ./Geometry.js */ \"./tools/Geometry.js\").Geometry;\r\nvar autopath = __webpack_require__(/*! ./autopath */ \"./tools/autopath.js\");\r\n\r\n\r\n\r\n\r\nvar counter = 0;\r\nvar total = 0;\r\n\r\nfunction Chunk(id){\r\n    this.id = id;\r\n    var origin = _shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].AOItoTile(this.id);\r\n    this.x = origin.x;\r\n    this.y = origin.y;\r\n    this.defaultTile = 'grass';\r\n    this.layers = [new SpaceMap()];\r\n    this.decor = [];\r\n    this.wood = new SpaceMap();\r\n}\r\n\r\nChunk.prototype.addDecor = function(x,y,v){\r\n    this.decor.push([x,y,v]);\r\n};\r\n\r\nChunk.prototype.addResource = function(x,y,r){\r\n    if(r == 'wood') this.wood.add(x,y);\r\n};\r\n\r\nChunk.prototype.add = function(x,y,v){ // Add tile\r\n    this.layers[0].add(x,y,v);\r\n};\r\n\r\nChunk.prototype.remove = function(x,y,v){\r\n    this.layers[0].delete(x,y);\r\n};\r\n\r\nChunk.prototype.get = function(x,y){\r\n    return this.layers[0].get(x,y);\r\n};\r\n\r\nChunk.prototype.trim = function(){\r\n    var layers = [];\r\n    this.layers.forEach(function(layer){\r\n       layers.push(layer.toList(true)); // true = compact list\r\n    });\r\n    return {\r\n        id: this.id,\r\n        x: this.x,\r\n        y: this.y,\r\n        default: this.defaultTile,\r\n        layers: layers,\r\n        decor: this.decor,\r\n        wood: this.wood.toList(true)\r\n    };\r\n};\r\n\r\nChunk.prototype.write = function(chunkpath){\r\n    var name = 'chunk'+this.id+'.json';\r\n    fs.writeFile(path.join(chunkpath,name),JSON.stringify(this.trim()),function(err){\r\n        if(err) throw err;\r\n        counter++;\r\n        if(counter == total) console.log(counter+' files written');\r\n    });\r\n};\r\n\r\nfunction WorldMaker(args){\r\n    this.outdir = '';\r\n    this.chunks = {};\r\n    this.coasts = [];\r\n\r\n    this.land = new SpaceMap();\r\n    this.collisions = new SpaceMap();\r\n    this.collisionsDebug = new SpaceMap();\r\n    this.items = new SpaceMap();\r\n    this.animals = new SpaceMap();\r\n    this.mapPixels = new SpaceMap();\r\n\r\n    this.tileset = null;\r\n    this.patterns = null;\r\n\r\n    this.nbHoriz = args.nbhoriz;\r\n    this.nbVert = args.nbvert;\r\n    this.chunkWidth = args.chunkw || 30;\r\n    this.chunkHeight = args.chunkh || 20;\r\n    this.tileWidth = args.tilew || 32;\r\n    this.tileHeight = args.tileh || 32;\r\n    this.blueprint = args.blueprint;\r\n\r\n    this.treeSource = args.treesource;\r\n    this.notreesave = args.notreesave;\r\n}\r\n\r\nWorldMaker.prototype.addCollision = function(x,y,source){\r\n    this.collisions.add(x,y,1);\r\n    this.collisionsDebug.add(x,y,source);\r\n};\r\n\r\nWorldMaker.prototype.run = function(){\r\n    if(!this.nbHoriz || !this.nbVert){\r\n        console.log('ERROR : Invalid arguments');\r\n        console.log('--nbhoriz : number of chunks horizontally (> 0)');\r\n        console.log('--nbvert : number of chunks vertically (> 0)');\r\n        console.log('(--chunkw : width of chunks in tiles, default '+defChunkW+')');\r\n        console.log('(--chunkh : height of chunks in tiles, default '+defChunkH+')');\r\n        console.log('(--tilew : width of tiles in px, default '+defTileW+')');\r\n        console.log('(--tileh : height of tiles in px, default '+defTileH+')');\r\n        return;\r\n    }\r\n\r\n    this.tileset = JSON.parse(fs.readFileSync(path.join(__dirname,'..','assets','tilesets','tileset.json')).toString());\r\n    this.patterns = JSON.parse(fs.readFileSync(path.join('tools','patterns.json')).toString());\r\n    var dataAssets = path.join(__dirname,'..','assets','data');\r\n    this.itemsData = JSON.parse(fs.readFileSync(path.join(dataAssets,'items.json')).toString());\r\n    this.animalsData = JSON.parse(fs.readFileSync(path.join(dataAssets,'animals.json')).toString());\r\n\r\n    this.outdir = path.join(__dirname,'..','maps'); // TODO: remove dev.mapsPath etc?\r\n    console.log('Writing to',this.outdir);\r\n\r\n    if(!fs.existsSync(this.outdir)) fs.mkdirSync(this.outdir);\r\n    var content = fs.readdirSync(this.outdir);\r\n    if (content.length > 0 ){\r\n        console.warn('Deleting existing world');\r\n        for(var i = 0; i < content.length; i++){\r\n            fs.unlinkSync(path.join(this.outdir,content[i]));\r\n        }\r\n    }\r\n\r\n    _shared_World__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(this.nbHoriz,this.nbVert,this.chunkWidth,this.chunkHeight,this.tileWidth,this.tileHeight);\r\n\r\n    var total = this.nbHoriz*this.nbVert;\r\n    for(var i = 0; i < total; i++){\r\n        this.chunks[i] = new Chunk(i);\r\n    }\r\n    console.log(total+' chunks created ('+this.nbHoriz+' x '+this.nbVert+')');\r\n\r\n    /*this.steps = {\r\n        'shape_world': this.shapeWorld, // Puts 'c' tiles on contours\r\n    }\r\n    this.stepsNames = this.steps.keys();\r\n    this.step = -1;*/\r\n\r\n    autopath.readImage(this.blueprint,this.storeImage.bind(this));\r\n};\r\n\r\n/*WorldMaker.prototype.proceed = function(){\r\n    if(++this.step >= this.stepsNames.length) return;\r\n    this.stepsNames\r\n};*/\r\n\r\nWorldMaker.prototype.storeImage = function(image){\r\n    this.image = image;\r\n    this.create();\r\n};\r\n\r\nWorldMaker.prototype.create = function(){\r\n    /*\r\n    * README:\r\n    * - Shores are first populated with 'c' tiles based on blueprint (shapeWorld)\r\n    * - Then the seas are filled, using 'c' tiles as stop tiles (createLakes)\r\n    * - Then the shores are actually drawn, replacing 'c' based on neighbors (drawShore)\r\n    * - Then forests are added (createForests)\r\n    * */\r\n    var contours = autopath.getContours(this.image);\r\n    this.shapeWorld(contours);\r\n    this.collectPixels();\r\n    this.createLakes();\r\n    this.drawShore();\r\n    this.createForests();\r\n    this.addMisc();\r\n    this.makeSpawnZones();\r\n\r\n    for(var id in this.chunks){\r\n        this.chunks[id].write(this.outdir);\r\n    }\r\n\r\n    this.writeDataFiles();\r\n    this.makeWorldmap();\r\n};\r\n\r\nWorldMaker.prototype.shapeWorld = function(contours){\r\n    // console.log(contours)\r\n    for(var i = 0; i < contours.length; i++) {\r\n        var lines = contours[i];\r\n        var nbPts = lines.length;\r\n        //console.log('processing curve '+i+' of length '+nbPts);\r\n        var tiles = [];\r\n        for (var j = 0; j < nbPts - 1; j++) {\r\n            var s = lines[j];\r\n            var e = lines[j+1];\r\n            s = this.pixelToTile({x:s[0],y:s[1]});\r\n            e = this.pixelToTile({x:e[0],y:e[1]});\r\n            var addTiles = Geometry.addCorners(Geometry.straightLine(s, e));\r\n            if (j > 0) addTiles.shift();\r\n            tiles = tiles.concat(addTiles);\r\n        }\r\n        tiles = Geometry.forwardSmoothPass(tiles);\r\n        tiles = Geometry.backwardSmoothPass(tiles);\r\n        if(tiles.length > 1) this.addCoastTiles(tiles);\r\n    }\r\n};\r\n\r\nWorldMaker.prototype.isBusy = function(node){\r\n    if(!isInWorldBounds(node.x,node.y)) return true;\r\n    return this.collisions.has(node.x,node.y);\r\n};\r\n\r\nfunction isInWorldBounds(x,y){\r\n    return !(x < 0 || y < 0 || x >= _shared_World__WEBPACK_IMPORTED_MODULE_1__[\"default\"].worldWidth || y >= _shared_World__WEBPACK_IMPORTED_MODULE_1__[\"default\"].worldHeight);\r\n}\r\n\r\nWorldMaker.prototype.addDecor = function(tile,decor){\r\n    var id = _shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].tileToAOI(tile);\r\n    if(!(id in this.chunks)) return;\r\n    var chunk = this.chunks[id];\r\n    chunk.addDecor(tile.x-chunk.x,tile.y-chunk.y,decor);\r\n};\r\n\r\nWorldMaker.prototype.addResource = function(x,y,resource){\r\n    var id = _shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].tileToAOI({x,y});\r\n    if(!(id in this.chunks)) return;\r\n    var chunk = this.chunks[id];\r\n    chunk.addResource(x-chunk.x,y-chunk.y,resource);\r\n};\r\n\r\n/*function removeTile(tile){\r\n    var id = Utils.tileToAOI(tile);\r\n    if(!(id in chunks)) return;\r\n    var chunk = chunks[id];\r\n    chunk.remove(tile.x-chunk.x,tile.y-chunk.y);\r\n}*/\r\n\r\nWorldMaker.prototype.addTile = function(tile,value){\r\n    var id = _shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].tileToAOI(tile);\r\n    if(!(id in this.chunks)) return;\r\n    var chunk = this.chunks[id];\r\n    chunk.add(tile.x-chunk.x,tile.y-chunk.y,value);\r\n};\r\n\r\nWorldMaker.prototype.getTile = function(x,y){\r\n    var id = _shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].tileToAOI({x:x,y:y});\r\n    if(!(id in this.chunks)) return;\r\n    var chunk = this.chunks[id];\r\n    return chunk.get(x-chunk.x,y-chunk.y);\r\n};\r\n\r\nWorldMaker.prototype.addCoastTiles = function(tiles){\r\n    var coast = [];\r\n    tiles.forEach(function(t) {\r\n        if(!isInWorldBounds(t.x,t.y)) return;\r\n        this.addTile(t,'c');\r\n        coast.push(t);\r\n    },this);\r\n    this.coasts.push(coast);\r\n};\r\n\r\nWorldMaker.prototype.collectPixels = function(){\r\n    this.greenpixels = [];\r\n    this.whitepixels = [];\r\n    var wm = this;\r\n    this.image.scan(0, 0, this.image.bitmap.width, this.image.bitmap.height, function (x, y, idx) {\r\n        //if(done) return;\r\n        // x, y is the position of this pixel on the image\r\n        // idx is the position start position of this rgba tuple in the bitmap Buffer\r\n        // this is the image\r\n\r\n        var red = this.bitmap.data[idx + 0];\r\n        var green = this.bitmap.data[idx + 1];\r\n        var blue = this.bitmap.data[idx + 2];\r\n\r\n        if(red == 203 && green == 230 && blue == 163) wm.greenpixels.push({x: x, y: y});\r\n        if(red == 255 && green == 255 && blue == 255) wm.whitepixels.push({x: x, y: y});\r\n\r\n        // Keep track of pixels that have also been mapped to land\r\n        // Due to space distortion, multiple pixels, black and white, can be mapped to the same tile!\r\n        if(red == 0 && green == 0 && blue == 0){\r\n            var g = wm.pixelToTile({x: x, y: y});\r\n            wm.land.add(g.x,g.y,1);\r\n        }\r\n    });\r\n}\r\n\r\nWorldMaker.prototype.pixelToTile = function(px){\r\n    return {\r\n        x: Math.round(px.x * (this.nbHoriz * this.chunkWidth / this.image.bitmap.width)),\r\n        y: Math.round(px.y * (this.nbVert * this.chunkHeight / this.image.bitmap.height))\r\n    };\r\n};\r\n\r\nWorldMaker.prototype.createLakes = function(){\r\n    console.log('Creating lakes ...');\r\n    // console.log(whitepixels.length,'white pixels');\r\n    var nblakes = 0;\r\n    for(var i = 0; i < this.whitepixels.length; i++){\r\n        var px = this.whitepixels[i];\r\n        var g = this.pixelToTile(px);\r\n        if(this.land.has(g.x,g.y)) continue;\r\n        var ok = true;\r\n        var contour = [[-1,0],[0,-1],[1,-1],[1,0],[0,1],[-1,1]];\r\n        for(var j = 0; j < contour.length; j++){\r\n            if(this.land.has(g.x+contour[j][0],g.y+contour[j][1]) || this.hasCoast(g.x+contour[j][0],g.y+contour[j][1])){\r\n                ok = false;\r\n                break;\r\n            }\r\n        }\r\n        if(ok){\r\n                var surface = this.fill(g);\r\n                if(surface > 100000) console.log(surface,px,g);\r\n                if (surface) nblakes++;\r\n        }\r\n    }\r\n    console.log(nblakes,'lakes created');\r\n};\r\n\r\nWorldMaker.prototype.canFill = function(node){\r\n    var t = this.getTile(node.x,node.y);\r\n    return !(t == 'c' || t == 'w');\r\n};\r\n\r\nWorldMaker.prototype.fill = function(fillNode,stop){ // fills the world with water, but stops at coastlines\r\n    // if(this.isBusy(fillNode)) return;\r\n    if(!this.canFill(fillNode)) return;\r\n    var stoppingCritetion = stop || 1000000;\r\n    var queue = [];\r\n    queue.push(fillNode);\r\n    var counter = 0;\r\n    var contour = [[-1,0],[-1,-1],[0,-1],[1,-1],[1,0],[1,1], [0,1],[-1,1]];\r\n    while(queue.length > 0){\r\n        var node = queue.shift();\r\n        if(this.isBusy(node)) continue;\r\n        if(!this.canFill(node)) continue;\r\n        // put a tile at location\r\n        this.addTile(node,'w');\r\n        // this.collisions.add(node.x,node.y,1);\r\n        this.addCollision(node.x,node.y,'water');\r\n        this.mapPixels.add(node.x,node.y,'w');\r\n        // expand\r\n        for(var i = 0; i < contour.length; i++){\r\n            var candidate = {\r\n                x: node.x + contour[i][0],\r\n                y: node.y + contour[i][1]\r\n            };\r\n            if(!isInWorldBounds(candidate.x,candidate.y)) continue;\r\n            // if(!this.isBusy(candidate)) queue.push(candidate);\r\n            if(this.canFill(candidate)) queue.push(candidate);\r\n        }\r\n\r\n        counter++;\r\n        if(counter >= stoppingCritetion) break;\r\n    }\r\n    return counter;\r\n};\r\n\r\nWorldMaker.prototype.hasCoast = function(x,y){\r\n    if(!isInWorldBounds(x,y)) return true; // When looking for a neighbor out of bounds, assume it's present; allows seamless connections with borders\r\n    var t = this.getTile(x,y);\r\n    return !(!t || t == 'w');\r\n};\r\n\r\nWorldMaker.prototype.hasWater = function(x,y){\r\n    return this.getTile(x,y) == 'w';\r\n};\r\n\r\nWorldMaker.prototype.drawShore = function(){\r\n    console.log('Drawing shore ...');\r\n    //var tiles = ['wb', 'wbbl', 'wbbr', 'wbtl', 'wbtr', 'wcbl', 'wcbr', 'wctl', 'wctr', 'wl', 'wr', 'wt','none'];\r\n\r\n    var undef = 0;\r\n    this.coasts.forEach(function(coast){\r\n        coast.forEach(function(c){\r\n            var x = c.x;\r\n            var y = c.y;\r\n            var tile;\r\n            var nbrh = this.getNeighborhood(x,y);\r\n            tile = this.patterns[nbrh.join('')];\r\n            if(tile === undefined) {\r\n                console.log(x,y,nbrh.join(''));\r\n                undef++;\r\n            }\r\n\r\n            if(tile !== undefined && tile != 'none'){\r\n                this.addTile(c,tile); // Will replace any 'c'\r\n                // if(this.collides(tile)) this.collisions.add(x,y,1);\r\n                if(this.collides(tile)) this.addCollision(x,y,'shore');\r\n                this.mapPixels.add(x,y,'c');\r\n            }\r\n        },this);\r\n    },this);\r\n    console.log(undef,'undef');\r\n};\r\n\r\n// Create the string of ggccwccw ... or surrounding tiles used to determine current one\r\nWorldMaker.prototype.getNeighborhood = function(x,y){\r\n    var res = [];\r\n    var contour = [[-1,0],[-1,-1],[0,-1],[1,-1],[1,0],[1,1], [0,1],[-1,1]];\r\n    for(var j = 0; j < contour.length; j++){\r\n        var v = 'g'; // -1\r\n        if(this.hasCoast(x+contour[j][0],y+contour[j][1])) v = 'c'; // 0\r\n        if(this.hasWater(x+contour[j][0],y+contour[j][1])) v = 'w'; // 1\r\n        res.push(v);\r\n    }\r\n    return res;\r\n};\r\n\r\nWorldMaker.prototype.collides = function(tile){\r\n    var longhand = this.tileset.shorthands[tile];\r\n    return this.tileset.frames[longhand].collides;\r\n};\r\n\r\nWorldMaker.prototype.createForests = function(){\r\n    console.log('Creating forests ...');\r\n    this.trees = new SpaceMap();\r\n    this.woodland = new SpaceMap();\r\n    if(this.treeSource){\r\n        this.restoreForest();\r\n        return;\r\n    }\r\n    var xRandRange = 7;\r\n    var yRandRange = 7;\r\n    var nbtrees = 0;\r\n    console.log(this.greenpixels.length,'green pixels');\r\n    for (var i = 0; i < this.greenpixels.length; i++) {\r\n        var px = this.greenpixels[i];\r\n        var g = this.pixelToTile(px);\r\n        g.x += _shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomInt(-xRandRange, xRandRange + 1);\r\n        g.y += _shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomInt(-yRandRange, yRandRange + 1);\r\n\r\n        var pos = this.checkPositions(g.x,g.y);\r\n        if(pos.length == 0) continue;\r\n\r\n        // TODO: move that up, to use tree type in positions computation\r\n        var type = getTreeType(g.x,g.y);\r\n        this.plantTree(g,pos,type);\r\n        nbtrees++;\r\n    }\r\n    console.log(nbtrees + ' trees planted');\r\n    if(this.notreesave) return;\r\n    fs.writeFile(path.join(__dirname,'blueprints','trees.json'),JSON.stringify(this.trees.toList()),function(err){\r\n        if(err) throw err;\r\n        console.log('Trees saved');\r\n    });\r\n};\r\n\r\nWorldMaker.prototype.plantTree = function(g,pos,type){\r\n    // g is {x,y} location\r\n    pos.forEach(function(p){\r\n        // this.collisions.add(p[0],p[1],1);\r\n        this.addCollision(p[0],p[1],'tree');\r\n    },this);\r\n    //TODO: adjust ranges / conf\r\n    for(var x = -4; x < 6; x++){\r\n        for(var y = -6; y < 5; y++){\r\n            this.woodland.add(parseInt(g.x)+x,parseInt(g.y)+y);\r\n            this.addResource(parseInt(g.x)+x,parseInt(g.y)+y,'wood');\r\n        }\r\n    }\r\n    this.trees.add(g.x,g.y,type);\r\n    this.addDecor(g, 't'+type);\r\n    this.addRandomItem(g.x,g.y,'tree');\r\n};\r\n\r\nWorldMaker.prototype.restoreForest = function(){\r\n    console.log('Restoring existing forest...');\r\n    var nbtrees = 0;\r\n    var trees = JSON.parse(fs.readFileSync(path.join('tools','blueprints','trees.json')).toString());\r\n    trees.forEach(function(t){\r\n        this.plantTree(t,this.checkPositions(t.x,t.y),t.v);\r\n        nbtrees++;\r\n    },this);\r\n    console.log(nbtrees + ' trees planted');\r\n};\r\n\r\nfunction getTreeType(x,y){\r\n    var poles = [Math.floor(_shared_World__WEBPACK_IMPORTED_MODULE_1__[\"default\"].worldHeight/2),_shared_World__WEBPACK_IMPORTED_MODULE_1__[\"default\"].worldHeight,0,Math.floor(_shared_World__WEBPACK_IMPORTED_MODULE_1__[\"default\"].worldHeight/4)]; // Pole for tree 1, 2, 3, 4 respectively\r\n    var dists = [];\r\n    var distsum = 0;\r\n    poles.forEach(function(p){\r\n        var d = Math.abs(y-p);\r\n        if(d == 0) d = 0.1;\r\n        d *= d; // Polarizes more\r\n        dists.push(d);\r\n        distsum += d;\r\n    });\r\n    var sumweights = 0;\r\n    var weights = dists.map(function(d){\r\n        var w = distsum/d;\r\n        sumweights += w;\r\n        return w;\r\n    });\r\n    var table = weights.map(function(w,i){\r\n        w = Math.round((w/sumweights)*10); // Normalization\r\n        if(w <= 2) w = 0;\r\n        return {weight: w, id: i+1};\r\n    });\r\n    var id = (_shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomInt(1,101) <= 1 ? 'd' : rwc(table));\r\n    return id;\r\n}\r\n\r\nWorldMaker.prototype.checkPositions = function(x,y){\r\n    var free = true;\r\n    var xspan = 3; //TODO: conf\r\n    var yspan = 2;\r\n    var pos = [];\r\n    for(var xi = 0; xi < xspan; xi++){\r\n        for(var yi = 0; yi < yspan; yi++){\r\n            var rx = parseInt(x)+xi;\r\n            var ry = parseInt(y)-yi;\r\n            pos.push([rx,ry]);\r\n            if(this.isBusy({x:rx,y:ry})) free = false;\r\n            if(!free) break;\r\n        }\r\n        if(!free) break;\r\n    }\r\n    if(!free) return [];\r\n    return pos;\r\n};\r\n\r\nWorldMaker.prototype.addMisc = function(){\r\n    console.log('Adding misc ...');\r\n    var nbrocks = 5000; //TODO: conf\r\n    var nbadded = 0;\r\n    for(var i = 0; i < nbrocks; i++){\r\n        // console.log('zone');\r\n        var x = _shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomInt(0,_shared_World__WEBPACK_IMPORTED_MODULE_1__[\"default\"].worldWidth);\r\n        var y = _shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomInt(0,_shared_World__WEBPACK_IMPORTED_MODULE_1__[\"default\"].worldHeight);\r\n        if(!this.isBusy({x:x,y:y})) {\r\n            this.addCollision(x,y,'misc');\r\n            this.items.add(x,y,26);\r\n            nbadded++;\r\n        }\r\n    }\r\n    console.log(nbadded,' stones added');\r\n};\r\n\r\nWorldMaker.prototype.getAnimalData = function(type){\r\n    var animalData = this.animalsData[type];\r\n    if(animalData.inheritFrom !== undefined) animalData = Object.assign(this.animalsData[animalData.inheritFrom],animalData);\r\n    return animalData;\r\n};\r\n\r\nWorldMaker.prototype.makeSpawnZones = function(){\r\n    this.resourceMarkers = [];\r\n    for(var itemID in this.itemsData){\r\n        var itemData = this.itemsData[itemID];\r\n        if(!itemData.nbClusters) continue;\r\n        for(var i = 0; i < itemData.nbClusters; i++){\r\n            var x = _shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomInt(0,_shared_World__WEBPACK_IMPORTED_MODULE_1__[\"default\"].worldWidth-1);\r\n            var y = _shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomInt(0,_shared_World__WEBPACK_IMPORTED_MODULE_1__[\"default\"].worldHeight-1);\r\n            var w = _shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomInt(5,_shared_World__WEBPACK_IMPORTED_MODULE_1__[\"default\"].chunkWidth);\r\n            var h = _shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomInt(5,_shared_World__WEBPACK_IMPORTED_MODULE_1__[\"default\"].chunkHeight);\r\n            this.makeFloraZone(x,y,w,h,itemID,itemData);\r\n        }\r\n    }\r\n\r\n    for(var animalID in this.animalsData){\r\n        var animalData = this.getAnimalData(animalID);\r\n        for(var i = 0; i < animalData.nbPacks; i++){\r\n            var x = _shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomInt(0,_shared_World__WEBPACK_IMPORTED_MODULE_1__[\"default\"].worldWidth-1);\r\n                var y = _shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomInt(0,_shared_World__WEBPACK_IMPORTED_MODULE_1__[\"default\"].worldHeight-1);\r\n                if(!this.collisions.get(x,y)) this.makeAnimalZone(x,y,animalID);\r\n        }\r\n    }\r\n};\r\n\r\nWorldMaker.prototype.makeFloraZone = function(x,y,w,h,item,data){\r\n    var contour = [[0,-1],[0,0],[0,1],[1,1],[1,0],[2,0],[2,1],[2,-1]];\r\n    var nb = 0;\r\n    var nbbushes = data.nbBushes || 4;\r\n    // Look for trees inside the given area\r\n    for(var u = 0; u < w; u++){\r\n        for(var v = 0; v < h; v++){\r\n            var tree = this.trees.get(x+u,y+v);\r\n            if(tree){\r\n                _shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shuffle(contour);\r\n                for(var j = 0; j < nbbushes; j++){\r\n                    var c = contour[j];\r\n                    var loc = {x:x+u+c[0],y:y+v+c[1]};\r\n                    if(data.decorFrame) this.addDecor(loc, data.decorFrame);\r\n                    this.items.add(loc.x,loc.y,item);\r\n                    nb++;\r\n                    // console.log('bush at',loc);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if(nb) this.resourceMarkers.push([Math.floor(x+w/2),Math.floor(y+h/2),item]);\r\n};\r\n\r\nWorldMaker.prototype.makeAnimalZone = function(x,y,type){\r\n    this.animals.add(x,y,type);\r\n    // this.animalsMarkers.push([x,y,type]);\r\n};\r\n\r\nWorldMaker.prototype.addRandomItem = function(x,y,decor){\r\n    var cnt = (decor == 'tree'\r\n        ? [[0,-1],[0,0],[0,1],[1,1],[1,0],[2,0],[2,1]]\r\n        : [[-1,0],[-1,-1],[0,-1],[1,-1],[1,0],[1,1], [0,1],[-1,1]]);\r\n    // var item = (decor == 'tree' ? 7 : 26); // wood or stone\r\n    var item = _shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomElement([7,7,7,30]); // wood or feathers TODO config\r\n    if(_shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomInt(1,10) > 8){ // TODO: adjust\r\n        var c = _shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomElement(cnt);\r\n        var ix = parseInt(x)+c[0];\r\n        var iy = parseInt(y)+c[1];\r\n        this.items.add(ix,iy,item);\r\n        // console.log('adding',item,'at',ix,iy);\r\n    }\r\n};\r\n\r\nWorldMaker.prototype.writeDataFiles = function(){\r\n    // Write master file\r\n    var master = {\r\n        chunkWidth: this.chunkWidth,\r\n        chunkHeight: this.chunkHeight,\r\n        nbChunksHoriz: this.nbHoriz,\r\n        nbChunksVert: this.nbVert\r\n    };\r\n    fs.writeFile(path.join(this.outdir,'master.json'),JSON.stringify(master),function(err){\r\n        if(err) throw err;\r\n        console.log('Master written');\r\n    });\r\n    // Write collisions\r\n    var colls = this.collisions.toList(true);\r\n    fs.writeFile(path.join(this.outdir,'collisions.json'),JSON.stringify(colls),function(err){\r\n        if(err) throw err;\r\n        console.log('Collisions written');\r\n    });\r\n    fs.writeFile(path.join(this.outdir,'collisions_debug.json'),JSON.stringify(this.collisionsDebug.toList(true)),function(err){\r\n        if(err) throw err;\r\n        console.log('Collisions debug written');\r\n    });\r\n    // Write resources\r\n    fs.writeFile(path.join(this.outdir,'woodland.json'),JSON.stringify(this.woodland.toList(true)),function(err){\r\n        if(err) throw err;\r\n        console.log('Woodland written');\r\n    });\r\n    // Write resource & animals markers\r\n    fs.writeFile(path.join(this.outdir,'resourceMarkers.json'),JSON.stringify(this.resourceMarkers),function(err){\r\n        if(err) throw err;\r\n        console.log('Resource markers written');\r\n    });\r\n    // fs.writeFile(path.join(this.outdir,'animalMarkers.json'),JSON.stringify(this.animalsMarkers),function(err){\r\n    //     if(err) throw err;\r\n    //     console.log('Animal markers written');\r\n    // });\r\n    // Items\r\n    fs.writeFile(path.join(this.outdir,'items.json'),JSON.stringify(this.items.toList(true)),function(err){\r\n        if(err) throw err;\r\n        console.log('Items written');\r\n    });\r\n    // Animals\r\n    fs.writeFile(path.join(this.outdir,'animals.json'),JSON.stringify(this.animals.toList(true)),function(err){\r\n        if(err) throw err;\r\n        console.log('Animals written');\r\n    });\r\n};\r\n\r\nWorldMaker.prototype.makeWorldmap = function(){\r\n    var wm = this;\r\n    var hexes  = {     // last two characters: ff = visible, 00 = not\r\n        'c': 0x000000ff,\r\n        'w': 0x68b89fff,\r\n        'trunk': 0x7e5d2eff,\r\n        't1': 0x91a54aff,\r\n        't2': 0x9dbf48ff, //0x809c3bff,\r\n        't3': 0x7f9b75ff,\r\n        't4': 0x375b44ff,\r\n        // 'g': 0x809c3bff\r\n    };\r\n    new Jimp(_shared_World__WEBPACK_IMPORTED_MODULE_1__[\"default\"].worldWidth*2, _shared_World__WEBPACK_IMPORTED_MODULE_1__[\"default\"].worldHeight*2, 0xf9de99ff, function (err, image) { // 0x0,\r\n        wm.mapPixels.toList(true).forEach(function(px){\r\n            var x = px[0]*2;\r\n            var y = px[1]*2;\r\n            var color = hexes[px[2]];\r\n            image.setPixelColor(color, x, y);\r\n            image.setPixelColor(color, x+1, y);\r\n            image.setPixelColor(color, x, y+1);\r\n            image.setPixelColor(color, x+1, y+1);\r\n        });\r\n        wm.trees.toList(true).forEach(function(t){\r\n            var x = t[0]*2;\r\n            var y = t[1]*2;\r\n            for(var xi = 0; xi < 4; xi++){\r\n                for(var yi = 0; yi > -4; yi--){\r\n                    image.setPixelColor(hexes['trunk'], x+xi, y+yi);\r\n                }\r\n            }\r\n            if(t[2] == 'd') return;\r\n            x -= 2;\r\n            y -= 10;\r\n            for(var xi = 0; xi < 8; xi++){\r\n                for(var yi = 0; yi < 8; yi++){\r\n                    image.setPixelColor(hexes['t'+t[2]], x+xi, y+yi);\r\n                }\r\n            }\r\n        });\r\n        // image.write(path.join(wm.outdir,'worldmap.png'));\r\n        image = wm.medianBlur(image,'worldmap.png');\r\n    });\r\n};\r\n\r\nWorldMaker.prototype.medianBlur = function(image,name){\r\n    var wm = this;\r\n    var iw = image.bitmap.width*4; // because each \"px\"is 4 values\r\n    var ih = image.bitmap.height*4;\r\n    new Jimp(image.bitmap.width, image.bitmap.height, 0xf9de99ff, function (err, newimage) {\r\n        image.scan(0, 0, image.bitmap.width, image.bitmap.height, function (x, y, idx) {\r\n            if (x == image.bitmap.width - 1 && y == image.bitmap.height - 1) {\r\n                // image scan finished, do your stuff\r\n                newimage.write(path.join(wm.outdir,name));\r\n                return;\r\n              }\r\n            // idx is the position start position of this rgba tuple in the bitmap Buffer\r\n            var r = wm.colorMedian(iw,ih,this.bitmap.data,idx,0); //this.bitmap.data[idx + 0];\r\n            var g = wm.colorMedian(iw,ih,this.bitmap.data,idx,1); //this.bitmap.data[idx + 1];\r\n            var b = wm.colorMedian(iw,ih,this.bitmap.data,idx,2); // this.bitmap.data[idx + 2];\r\n            var a = this.bitmap.data[idx + 3];\r\n            // color = image.getPixelColor(x,y);\r\n            var color = Jimp.rgbaToInt(r, g, b, a);\r\n            newimage.setPixelColor(color, x,y);\r\n        });\r\n    });\r\n};\r\n\r\nWorldMaker.prototype.colorMedian = function(w,h,data,idx,offset){\r\n    var idcs = _shared_Utils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].listNeighborsInGrid(idx,w,h,4);\r\n\r\n    var px = [];\r\n    idcs.forEach(function(i){\r\n        if(data[i+offset] != undefined) px.push(data[i+offset]);\r\n    });\r\n\r\n    var  l = px.length;\r\n    var n = (l%2 == 0 ? (l/2)-1 : (l-1)/2);\r\n    quickselect(px,n);\r\n    // console.log(w,h);\r\n    // console.log(idx)\r\n    // console.log(idcs)\r\n    // console.log(px)\r\n    // console.log('result:',px[n]);\r\n    return px[n];\r\n};\r\n\r\nvar args = __webpack_require__(/*! optimist */ \"optimist\").argv;\r\n\r\nvar wm = new WorldMaker(args);\r\nwm.run();\r\n\n\n//# sourceURL=webpack:///./tools/worldMaker.js?");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"fs\");\n\n//# sourceURL=webpack:///external_%22fs%22?");

/***/ }),

/***/ "jimp":
/*!***********************!*\
  !*** external "jimp" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"jimp\");\n\n//# sourceURL=webpack:///external_%22jimp%22?");

/***/ }),

/***/ "optimist":
/*!***************************!*\
  !*** external "optimist" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"optimist\");\n\n//# sourceURL=webpack:///external_%22optimist%22?");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"path\");\n\n//# sourceURL=webpack:///external_%22path%22?");

/***/ }),

/***/ "quickselect":
/*!******************************!*\
  !*** external "quickselect" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"quickselect\");\n\n//# sourceURL=webpack:///external_%22quickselect%22?");

/***/ }),

/***/ "random-weighted-choice":
/*!*****************************************!*\
  !*** external "random-weighted-choice" ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"random-weighted-choice\");\n\n//# sourceURL=webpack:///external_%22random-weighted-choice%22?");

/***/ })

/******/ });